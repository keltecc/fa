## Структура

- В директории [src/](src/) находится исходный код приложения FastAPI. API реализован в [src/app.py](src/app.py), сервисы для пользователей и задач в [src/services.py](src/services.py)

- Все данные хранятся в PostgreSQL, см [src/database.py](src/database.py)

- В файле [migration.sql](migration.sql) находится миграция для инициализации базы

- Как запустить:

```sh
docker compose up --build -d
```

- Как остановить:

```sh
docker compose down
```

- Можно запустить и без докера, тогда нужно поднять PostgreSQL и прописать в переменную окружения `DATABASE_URI` путь до базы, затем прогнать миграцию например так

```sh
psql 'postgres://postgres:postgres@0.0.0.0:5432/postgres' < migration.sql
```

## Что реализовано

- Регистрация пользователей, JWT-токен хранится в cookie. Все задачи привязаны к пользователю. Токен ставится и проверяется в middleware (см [src/middlewares.py](src/middlewares.py))

```
/users/register
/users/login
/users/logout
```

- CRUD над задачами, задача содержит название, описание, статус, приоритет и дату создания

```
/tasks/create
/tasks/get/<task_id>
/tasks/update/<task_id>
/tasks/delete/<task_id>
```

- Листинг задач, они отсортированы по убыванию приоритета. Можно указать параметр `count`, тогда вернутся `count` самых приоритетных задач

```
/tasks/list
/tasks/list?count=<count>
```

- Текстовый поиск по названию и описанию задачи

```
/tasks/search?text=<text>
```

- Кэширование добавлено только для удаления задач \
\- Мы не можем однозначно кэшировать операции с пользователем поскольку они зависят от состояния базы и могут давать разные ответы (например первый register возвращает успех а второй такой же уже ошибку, для login вообще нужно хранить сами пароли в кэше получается) \
\- Мы также не можем кэшировать создание, получение (листинг, поиск) и редактирование задачи, поскольку они тоже зависят от состояния базы (например не можем кэшировать GET, так как после DELETE ответ будет другой) \
\- Единственное для чего я нашёл возможным добавить кэш это для DELETE задач, поскольку это идемпотентная операция и она всегда возвращает одинаковый ответ. При этом id задач генерируется сервером и случайно (uuid), из-за этого у нас не может быть ситуации при которой DELETE вызовется перед созданием задачи и закешируется (поскольку невозможно угадать id созданной задачи) \
\- Кэш реализован тупо через `set()` запросов, навешивание `functools.cache` сдохло из-за корутины

## Что не реализовано

- Сортировка по различным критериям

## Как проверить

- Есть файл [test.py](test.py), в нём описаны тестовые сценарии

- Как запустить:

```sh
python3 test.py
```

## Пример объекта задачи

```json
{
    "id": "31d01d21-57d9-432e-b7c0-9c9121e0c343",
    "owner": "ef9bb6005048ce9f",
    "title": "title1",
    "description": "description1",
    "status": "InProgress",
    "priority": 2,
    "created_at": "2025-03-24T01:24:11.210834",
    "updated_at": "2025-03-24T01:24:11.225646"
}
```
